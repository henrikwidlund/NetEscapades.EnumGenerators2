//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NetEscapades.EnumGenerators source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable
using System;

namespace MyTestNameSpace
{
    /// <summary>
    /// Extension methods for <see cref="MyTestNameSpace.MyEnum" />.
    /// </summary>
    public static partial class MyEnumExtensions
    {
        /// <summary>
        /// The number of members in the enum.
        /// This is a non-distinct count of defined names.
        /// </summary>
        public const int Length = 4;

        /// <summary>
        /// Returns the string representation of the <see cref="MyTestNameSpace.MyEnum"/> value.
        /// If the attribute is decorated with a <c>[Display]</c> attribute, then
        /// uses the provided value. Otherwise uses the name of the member, equivalent to
        /// calling <c>ToString()</c> on <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to retrieve the string value for.</param>
        /// <returns>The string representation of the value.</returns>
        public static string ToStringFast(this MyTestNameSpace.MyEnum value)
            => value switch
            {
                MyTestNameSpace.MyEnum.First => nameof(MyTestNameSpace.MyEnum.First),
                MyTestNameSpace.MyEnum.Second => "2nd",
                MyTestNameSpace.MyEnum.Third => nameof(MyTestNameSpace.MyEnum.Third),
                MyTestNameSpace.MyEnum.Fourth => "4th",
                _ => value.ToString()
            };

        /// <summary>
        /// Returns a boolean telling whether the given enum value exists in the enumeration.
        /// </summary>
        /// <param name="value">The value to check if it's defined.</param>
        /// <returns><see langword="true" /> if the value exists in the enumeration, <see langword="false" /> otherwise.</returns>
        public static bool IsDefined(MyTestNameSpace.MyEnum value)
            => value switch
            {
                MyTestNameSpace.MyEnum.First => true,
                MyTestNameSpace.MyEnum.Second => true,
                MyTestNameSpace.MyEnum.Third => true,
                MyTestNameSpace.MyEnum.Fourth => true,
                _ => false
            };

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration.
        /// </summary>
        /// <param name="name">The name to check if it's defined.</param>
        /// <returns><see langword="true" /> if a member with the name exists in the enumeration, <see langword="false" /> otherwise.</returns>
        public static bool IsDefined(string name) => IsDefined(name, false);

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,
        /// or if a member decorated with a <c>[Display]</c> attribute
        /// with the required name exists.
        /// </summary>
        /// <param name="name">The name to check if it's defined.</param>
        /// <param name="allowMatchingMetadataAttribute">If <see langword="true" />, considers the value of metadata attributes,otherwise ignores them.</param>
        /// <returns><see langword="true" /> if a member with the name exists in the enumeration, or a member is decorated
        /// with a <c>[Display]</c> attribute with the name, <see langword="false" /> otherwise.</returns>
        public static bool IsDefined(string name, bool allowMatchingMetadataAttribute)
        {
            var isDefinedInDisplayAttribute = false;
            if (allowMatchingMetadataAttribute)
            {
                isDefinedInDisplayAttribute = name switch
                {
                    "2nd" => true,
                    "4th" => true,
                    _ => false
                };
            }

            if (isDefinedInDisplayAttribute)
            {
                return true;
            }

            return name switch
            {
                nameof(MyTestNameSpace.MyEnum.First) => true,
                nameof(MyTestNameSpace.MyEnum.Second) => true,
                nameof(MyTestNameSpace.MyEnum.Third) => true,
                nameof(MyTestNameSpace.MyEnum.Fourth) => true,
                _ => false
            };
        }

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration.
        /// </summary>
        /// <param name="name">The name to check if it's defined.</param>
        /// <returns><see langword="true" /> if a member with the name exists in the enumeration, <see langword="false" /> otherwise.</returns>
        public static bool IsDefined(in ReadOnlySpan<char> name) => IsDefined(name, false);

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,
        /// or optionally if a member decorated with a <c>[Display]</c> attribute
        /// with the required name exists.
        /// </summary>
        /// <param name="name">The name to check if it's defined.</param>
        /// <param name="allowMatchingMetadataAttribute">If <see langword="true" />, considers the value of metadata attributes, otherwise ignores them.</param>
        /// <returns><see langword="true" /> if a member with the name exists in the enumeration, or a member is decorated
        /// with a <c>[Display]</c> attribute with the name, <see langword="false" /> otherwise.</returns>
        public static bool IsDefined(in ReadOnlySpan<char> name, bool allowMatchingMetadataAttribute)
        {
            var isDefinedInDisplayAttribute = false;
            if (allowMatchingMetadataAttribute)
            {
                isDefinedInDisplayAttribute = name switch
                {
                    var current when current.Equals(_secondEnumDisplayMemory.Span, global::System.StringComparison.Ordinal) => true,
                    var current when current.Equals(_fourthEnumDisplayMemory.Span, global::System.StringComparison.Ordinal) => true,
                    _ => false
                };
            }

            if (isDefinedInDisplayAttribute)
            {
                return true;
            }

            return name switch
            {
                var current when current.Equals(_firstEnumMemory.Span, global::System.StringComparison.Ordinal) => true,
                var current when current.Equals(_secondEnumMemory.Span, global::System.StringComparison.Ordinal) => true,
                var current when current.Equals(_thirdEnumMemory.Span, global::System.StringComparison.Ordinal) => true,
                var current when current.Equals(_fourthEnumMemory.Span, global::System.StringComparison.Ordinal) => true,
                _ => false
            };
        }

        private static readonly ReadOnlyMemory<char> _firstEnumMemory = "First".AsMemory();
        private static readonly ReadOnlyMemory<char> _secondEnumMemory = "Second".AsMemory();
        private static readonly ReadOnlyMemory<char> _thirdEnumMemory = "Third".AsMemory();
        private static readonly ReadOnlyMemory<char> _fourthEnumMemory = "Fourth".AsMemory();
        private static readonly ReadOnlyMemory<char> _secondEnumDisplayMemory = "2nd".AsMemory();
        private static readonly ReadOnlyMemory<char> _fourthEnumDisplayMemory = "4th".AsMemory();

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="MyTestNameSpace.MyEnum" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert.</param>
        /// <param name="value">When this method returns, contains an object of type
        /// <see cref="MyTestNameSpace.MyEnum" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="MyTestNameSpace.MyEnum" />. This parameter is passed uninitialized.</param>
        /// <returns><see langword="true" /> if the value parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
            string? name,
            out MyTestNameSpace.MyEnum value)
            => TryParse(name, out value, false, false);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="MyTestNameSpace.MyEnum" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The string representation of the enumeration name or underlying value to convert.</param>
        /// <param name="value">When this method returns, contains an object of type
        /// <see cref="MyTestNameSpace.MyEnum" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="MyTestNameSpace.MyEnum" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <returns><see langword="true" /> if the value parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
            string? name,
            out MyTestNameSpace.MyEnum value,
            bool ignoreCase)
            => TryParse(name, out value, ignoreCase, false);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="MyTestNameSpace.MyEnum" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The string representation of the enumeration name or underlying value to convert.</param>
        /// <param name="value">When this method returns, contains an object of type
        /// <see cref="MyTestNameSpace.MyEnum" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="MyTestNameSpace.MyEnum" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <see langword="true" />, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns><see langword="true" /> if the value parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
            string? name,
            out MyTestNameSpace.MyEnum value,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
        {
            if (allowMatchingMetadataAttribute)
            {
                if (ignoreCase)
                {
                    switch (name)
                    {
                        case not null when name.Equals("2nd", global::System.StringComparison.OrdinalIgnoreCase):
                            value = MyTestNameSpace.MyEnum.Second;
                            return true;
                        case not null when name.Equals("4th", global::System.StringComparison.OrdinalIgnoreCase):
                            value = MyTestNameSpace.MyEnum.Fourth;
                            return true;
                    }
                }
                else
                {
                    switch (name)
                    {
                        case "2nd":
                            value = MyTestNameSpace.MyEnum.Second;
                            return true;
                        case "4th":
                            value = MyTestNameSpace.MyEnum.Fourth;
                            return true;
                    }
                }
            }

            if (ignoreCase)
            {
                switch (name)
                {
                    case not null when name.Equals(nameof(MyTestNameSpace.MyEnum.First), global::System.StringComparison.OrdinalIgnoreCase):
                        value = MyTestNameSpace.MyEnum.First;
                        return true;
                    case not null when name.Equals(nameof(MyTestNameSpace.MyEnum.Second), global::System.StringComparison.OrdinalIgnoreCase):
                        value = MyTestNameSpace.MyEnum.Second;
                        return true;
                    case not null when name.Equals(nameof(MyTestNameSpace.MyEnum.Third), global::System.StringComparison.OrdinalIgnoreCase):
                        value = MyTestNameSpace.MyEnum.Third;
                        return true;
                    case not null when name.Equals(nameof(MyTestNameSpace.MyEnum.Fourth), global::System.StringComparison.OrdinalIgnoreCase):
                        value = MyTestNameSpace.MyEnum.Fourth;
                        return true;
                    case { Length: > 0 } when int.TryParse(name, out var val):
                        value = (MyTestNameSpace.MyEnum)val;
                        return true;
                    default:
                        value = default;
                        return false;
                }
            }

            switch (name)
            {
                case nameof(MyTestNameSpace.MyEnum.First):
                    value = MyTestNameSpace.MyEnum.First;
                    return true;
                case nameof(MyTestNameSpace.MyEnum.Second):
                    value = MyTestNameSpace.MyEnum.Second;
                    return true;
                case nameof(MyTestNameSpace.MyEnum.Third):
                    value = MyTestNameSpace.MyEnum.Third;
                    return true;
                case nameof(MyTestNameSpace.MyEnum.Fourth):
                    value = MyTestNameSpace.MyEnum.Fourth;
                    return true;
                case { Length: > 0 } when int.TryParse(name, out var val):
                    value = (MyTestNameSpace.MyEnum)val;
                    return true;
                default:
                    value = default;
                    return false;
            }
        }

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="MyTestNameSpace.MyEnum" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert.</param>
        /// <param name="value">When this method returns, contains an object of type
        /// <see cref="MyTestNameSpace.MyEnum" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="MyTestNameSpace.MyEnum" />. This parameter is passed uninitialized.</param>
        /// <returns><see langword="true" /> if the value parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
            in ReadOnlySpan<char> name,
            out MyTestNameSpace.MyEnum value)
            => TryParse(name, out value, false, false);

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="MyTestNameSpace.MyEnum" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert.</param>
        /// <param name="value">When this method returns, contains an object of type
        /// <see cref="MyTestNameSpace.MyEnum" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="MyTestNameSpace.MyEnum" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <returns><see langword="true" /> if the value parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
            in ReadOnlySpan<char> name,
            out MyTestNameSpace.MyEnum value,
            bool ignoreCase)
            => TryParse(name, out value, ignoreCase, false);

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="MyTestNameSpace.MyEnum" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert.</param>
        /// <param name="result">When this method returns, contains an object of type
        /// <see cref="MyTestNameSpace.MyEnum" /> whose
        /// value is represented by <paramref name="result"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="MyTestNameSpace.MyEnum" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <see langword="true" />, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns><see langword="true" /> if the value parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
            in ReadOnlySpan<char> name,
            out MyTestNameSpace.MyEnum result,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
        {
            if (allowMatchingMetadataAttribute)
            {
                if (ignoreCase)
                {
                    switch (name)
                    {
                        case var current when current.Equals(_secondEnumDisplayMemory.Span, global::System.StringComparison.OrdinalIgnoreCase):
                            result = MyTestNameSpace.MyEnum.Second;
                            return true;
                        case var current when current.Equals(_fourthEnumDisplayMemory.Span, global::System.StringComparison.OrdinalIgnoreCase):
                            result = MyTestNameSpace.MyEnum.Fourth;
                            return true;
                    }
                }
                else
                {
                    switch (name)
                    {
                        case var current when current.Equals(_secondEnumDisplayMemory.Span, global::System.StringComparison.Ordinal):
                            result = MyTestNameSpace.MyEnum.Second;
                            return true;
                        case var current when current.Equals(_fourthEnumDisplayMemory.Span, global::System.StringComparison.Ordinal):
                            result = MyTestNameSpace.MyEnum.Fourth;
                            return true;
                    }
                }
            }

            if (ignoreCase)
            {
                switch (name)
                {
                    case var current when current.Equals(_firstEnumMemory.Span, global::System.StringComparison.OrdinalIgnoreCase):
                        result = MyTestNameSpace.MyEnum.First;
                        return true;
                    case var current when current.Equals(_secondEnumMemory.Span, global::System.StringComparison.OrdinalIgnoreCase):
                        result = MyTestNameSpace.MyEnum.Second;
                        return true;
                    case var current when current.Equals(_thirdEnumMemory.Span, global::System.StringComparison.OrdinalIgnoreCase):
                        result = MyTestNameSpace.MyEnum.Third;
                        return true;
                    case var current when current.Equals(_fourthEnumMemory.Span, global::System.StringComparison.OrdinalIgnoreCase):
                        result = MyTestNameSpace.MyEnum.Fourth;
                        return true;
                    case { IsEmpty: false } when int.TryParse(name, out var numericResult):
                        result = (MyTestNameSpace.MyEnum)numericResult;
                        return true;
                    default:
                        result = default;
                        return false;
                }
            }

            switch (name)
            {
                case var current when current.Equals(_firstEnumMemory.Span, global::System.StringComparison.Ordinal):
                    result = MyTestNameSpace.MyEnum.First;
                    return true;
                case var current when current.Equals(_secondEnumMemory.Span, global::System.StringComparison.Ordinal):
                    result = MyTestNameSpace.MyEnum.Second;
                    return true;
                case var current when current.Equals(_thirdEnumMemory.Span, global::System.StringComparison.Ordinal):
                    result = MyTestNameSpace.MyEnum.Third;
                    return true;
                case var current when current.Equals(_fourthEnumMemory.Span, global::System.StringComparison.Ordinal):
                    result = MyTestNameSpace.MyEnum.Fourth;
                    return true;
                case { IsEmpty: false } when int.TryParse(name, out var numericResult):
                    result = (MyTestNameSpace.MyEnum)numericResult;
                    return true;
                default:
                    result = default;
                    return false;
            }
        }

        /// <summary>
        /// Retrieves an array of the metadata or <see langword="default" /> values of the members defined in
        /// <see cref="MyTestNameSpace.MyEnum" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the metadata or <see langword="default" /> values defined in <see cref="MyTestNameSpace.MyEnum" />.</returns>
        public static string[] GetMetadataNamesOrDefault() =>
            new[]
            {
                nameof(MyTestNameSpace.MyEnum.First),
                "2nd",
                nameof(MyTestNameSpace.MyEnum.Third),
                "4th",
            };

        /// <summary>
        /// Gets the <see cref="MyTestNameSpace.MyEnum" /> representation of the <paramref name="name"/>
        /// or <see langword="default" /> if there's no match.
        /// </summary>
        /// <param name="name">The value that should be matched.</param>
        /// <returns>The matching <see cref="MyTestNameSpace.MyEnum" /> or <see langword="null" /> if there was no match.</returns>
        public static MyTestNameSpace.MyEnum? GetValueOrDefault(string? name) =>
            TryParse(name, out MyTestNameSpace.MyEnum value) ? value : null;

        /// <summary>
        /// Gets the <see cref="MyTestNameSpace.MyEnum" /> representation of the <paramref name="name"/>
        /// or <see langword="default" /> if there's no match.
        /// </summary>
        /// <param name="name">The value that should be matched.</param>
        /// <returns>The matching <see cref="MyTestNameSpace.MyEnum" /> or <see langword="null" /> if there was no match.</returns>
        public static MyTestNameSpace.MyEnum? GetValueOrDefault(in ReadOnlySpan<char> name) =>
            TryParse(name, out MyTestNameSpace.MyEnum value) ? value : null;

        /// <summary>
        /// Gets the <see cref="MyTestNameSpace.MyEnum" /> representation of the <paramref name="name"/>
        /// or <see langword="default" /> if there's no match.
        /// </summary>
        /// <param name="name">The value that should be matched.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <returns>The matching <see cref="MyTestNameSpace.MyEnum" /> or <see langword="null" /> if there was no match.</returns>
        public static MyTestNameSpace.MyEnum? GetValueOrDefault(string? name, bool ignoreCase) =>
            TryParse(name, out MyTestNameSpace.MyEnum value, ignoreCase) ? value : null;

        /// <summary>
        /// Gets the <see cref="MyTestNameSpace.MyEnum" /> representation of the <paramref name="name"/>
        /// or <see langword="default" /> if there's no match.
        /// </summary>
        /// <param name="name">The value that should be matched.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <returns>The matching <see cref="MyTestNameSpace.MyEnum" /> or <see langword="null" /> if there was no match.</returns>
        public static MyTestNameSpace.MyEnum? GetValueOrDefault(in ReadOnlySpan<char> name, bool ignoreCase) =>
            TryParse(name, out MyTestNameSpace.MyEnum value, ignoreCase) ? value : null;

        /// <summary>
        /// Gets the <see cref="MyTestNameSpace.MyEnum" /> representation of the <paramref name="name"/>
        /// or <see langword="default" /> if there's no match.
        /// </summary>
        /// <param name="name">The value that should be matched.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <see langword="true" />, considers the value of metadata attributes,otherwise ignores them.</param>
        /// <returns>The matching <see cref="MyTestNameSpace.MyEnum" /> or <see langword="null" /> if there was no match.</returns>
        public static MyTestNameSpace.MyEnum? GetValueOrDefault(string? name, bool ignoreCase, bool allowMatchingMetadataAttribute) =>
            TryParse(name, out MyTestNameSpace.MyEnum value, ignoreCase, allowMatchingMetadataAttribute) ? value : null;

        /// <summary>
        /// Gets the <see cref="MyTestNameSpace.MyEnum" /> representation of the <paramref name="name"/>
        /// or <see langword="default" /> if there's no match.
        /// </summary>
        /// <param name="name">The value that should be matched.</param>
        /// <param name="ignoreCase"><see langword="true" /> to read value in case insensitive mode; <see langword="false" /> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <see langword="true" />, considers the value of metadata attributes,otherwise ignores them.</param>
        /// <returns>The matching <see cref="MyTestNameSpace.MyEnum" /> or <see langword="null" /> if there was no match.</returns>
        public static MyTestNameSpace.MyEnum? GetValueOrDefault(in ReadOnlySpan<char> name, bool ignoreCase, bool allowMatchingMetadataAttribute) =>
            TryParse(name, out MyTestNameSpace.MyEnum value, ignoreCase, allowMatchingMetadataAttribute) ? value : null;

        /// <summary>
        /// Retrieves an array of the values of the members defined in
        /// <see cref="MyTestNameSpace.MyEnum" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the values defined in <see cref="MyTestNameSpace.MyEnum" />.</returns>
        public static MyTestNameSpace.MyEnum[] GetValues() =>
            new[]
            {
                MyTestNameSpace.MyEnum.First,
                MyTestNameSpace.MyEnum.Second,
                MyTestNameSpace.MyEnum.Third,
                MyTestNameSpace.MyEnum.Fourth,
            };


        /// <summary>
        /// Retrieves an array of the names of the members defined in
        /// <see cref="MyTestNameSpace.MyEnum" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the names of the members defined in <see cref="MyTestNameSpace.MyEnum" />.</returns>
        public static string[] GetNames() =>
            new[]
            {
                nameof(MyTestNameSpace.MyEnum.First),
                nameof(MyTestNameSpace.MyEnum.Second),
                nameof(MyTestNameSpace.MyEnum.Third),
                nameof(MyTestNameSpace.MyEnum.Fourth),
            };
    }
}